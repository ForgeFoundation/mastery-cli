term;example;prompt;description;attachment
search-problem;;In which parts does a search problem consists of?;"    A search problem consists of:          A State Space. Set of all possible states where you can be.         A Start State. The state from where the search begins.         A Goal Test. A function that looks at the current state returns whether or not it is the goal state.     The Solution to a search problem is a sequence of actions, called the plan that transforms the start state to the goal state.     This plan is achieved through search algorithms.";
each-algorithm-has;;Explain either: graph, strategy, fringe, tree, or solution plan;"    A problem graph, containing the start node S and the goal node G.    A problem graph, containing the start node S and the goal node G.
    A strategy, describing the manner in which the graph will be traversed to get to G.
    A fringe, which is a data structure used to store all the possible states (nodes) that you can go from the current states.
    A tree, that results while traversing to the goal node.
    A solution plan, which the sequence of nodes from S to G.";
depth-first-search;"    d = the depth of the search tree = the number of levels of the search tree.      n^i = number of nodes in level i .       Time complexity: Equivalent to the number of nodes traversed in DFS. T(n) = 1 + n^2 + n^3 + ... + n^d = O(n^d)     Space complexity: Equivalent to how large can the fringe get. S(n) = O(n \times d)     Completeness: DFS is complete if the search tree is finite, meaning for a given finite search tree, DFS will come up with a solution if it exists.      Optimality: DFS is not optimal, meaning the number of steps in reaching the solution, or the cost spent in reaching it is high. ";Talk about either the Time Complexity, Space Complexity, Completeness, Optimality;Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. It uses last in- first-out strategy and hence it is implemented using a stack.;
breadth-first-search;"     s = the depth of the shallowest solution.      n^i = number of nodes in level i .      Time complexity: Equivalent to the number of nodes traversed in BFS until the shallowest solution. T(n) = 1 + n^2 + n^3 + ... + n^s = O(n^s)     Space complexity: Equivalent to how large can the fringe get. S(n) = O(n^s)     Completeness: BFS is complete, meaning for a given search tree, BFS will come up with a solution if it exists.       Optimality: BFS is optimal as long as the costs of all edges are equal. ";Talk about either the Time Complexity, Space Complexity, Completeness, Optimality;Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a ‘search key’), and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. It is implemented using a queue.;
uniform-cost-search;Advantages:       UCS is complete only if states are finite and there should be no loop with zero weight.     UCS is optimal only if there is no negative cost.  Disadvantages:       Explores options in every “direction”.     No information on goal location.;What are the advantages and disadvantages of UCS?;"UCS is different from BFS and DFS because here the costs come into play. In other words, traversing via different edges might not have the same cost. The goal is to find a path where the cumulative sum of costs is the least. ";
greedy-search;;"Explain and when would you use this algorithm?
";In a greedy search algorithm, we start with an initial state and a goal state, and we try to find the shortest path from the initial state to the goal state by selecting the path that appears to be closest to the goal. This is done by using a heuristic function to estimate the distance between the current state and the goal state.  At each step of the algorithm, we expand the node with the lowest heuristic value (i.e., the node that appears to be closest to the goal) and generate all the possible successor nodes. We then evaluate the heuristic function for each of these successor nodes and add them to a priority queue. The next node to expand is the node at the front of the priority queue.;
perfect-information;;Whats the difference between perfect information adn imperfect information;Perfect information: A game with the perfect information is that in which agents can look into the complete board. Agents have all the information about the game, and they can see each other moves also. Examples are Chess, Checkers, Go, etc. Imperfect information: If in a game agents do not have all information about the game and not aware with what's going on, such type of games are called the game with imperfect information, such as Battleship, blind, Bridge, etc.;
deterministic-games;;Whats the difference between deterministic and non-deterministic game;Deterministic games: Deterministic games are those games which follow a strict pattern and set of rules for the games, and there is no randomness associated with them. Examples are chess, Checkers, Go, tic-tac-toe, etc. Non-deterministic games: Non-deterministic are those games which have various unpredictable events and has a factor of chance or luck. This factor of chance or luck is introduced by either dice or cards. These are random, and each action response is not fixed. Such games are also called as stochastic games. Example: Backgammon, Monopoly, Poker, etc.;
;;;;
;;;;